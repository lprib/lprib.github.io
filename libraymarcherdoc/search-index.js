var searchIndex = JSON.parse('{\
"libraymarcher":{"doc":"","i":[[3,"Julia","libraymarcher","A Julia set defined by a Quaternion c value (used in z =…",null,null],[12,"c","","The c value used in `z^2 + c` iteration",0,null],[12,"color","","Color of this object in the scene",0,null],[3,"Quaternion","","Quaternion type, a 4 dimensional number type.",null,null],[3,"RayResult","","",null,null],[12,"len","","Length in units of the ray",1,null],[12,"hit_point","","Where the ray intersected the scene in space",1,null],[3,"RayMarcher","","",null,null],[12,"object","","Object or scene to render",2,null],[12,"config","","Configuration to run under. see `RayMarcherConfig`",2,null],[3,"RayMarcherConfig","","",null,null],[12,"width","","Width of the rendered image in px",3,null],[12,"height","","Height of the rendered image in px",3,null],[12,"camera_pos","","Camera position in 3d space",3,null],[12,"look_at","","Point that the camera should point towards (usually leave…",3,null],[12,"light_pos","","Position of the Phong directional light in 3d space",3,null],[12,"background_color","","Color to render if a ray missed the scene",3,null],[12,"camera_zoom","","Zoom level of the camera. 1.0 normal zoom",3,null],[12,"anti_aliasing_level","","Size of subpixel grid. anti_aliasing_level of 4 will…",3,null],[12,"backplane_positions","","Position of the back culling planes. Any rays that hit…",3,null],[12,"specular_shininess","","Phong shininess constant",3,null],[12,"specular_color","","Color of specular highlights",3,null],[3,"Sphere","","Simple sphere distance field",null,null],[12,"center","","",4,null],[12,"radius","","",4,null],[12,"color","","",4,null],[3,"Vec3","","A 3 dimensional vector of `f64`",null,null],[12,"x","","",5,null],[12,"y","","",5,null],[12,"z","","",5,null],[5,"cast_ray","","Performs the raymarching algorithm on a scene.",null,[[["vec3",3]],[["rayresult",3],["option",4]]]],[11,"new","","Constructs a new Quaternion. `r` is the real value. `i`,…",6,[[]]],[11,"magnitude","","Magnuitude of this Quaternion, using the Euclidean norm.",6,[[]]],[11,"get_pixel_color","","Marches a ray (and secondary rays) to get a final color.…",2,[[]]],[11,"magnitude","","The Euclidean norm",5,[[]]],[11,"dot","","Dot product with another Vec3",5,[[["vec3",3]]]],[11,"normalized","","Normalize this Vec3 so that it has a magnitude of 1",5,[[]]],[11,"reflect","","Reflect this vector about a normal vec.",5,[[["vec3",3]]]],[11,"cross","","Cross product with another Vec3",5,[[["vec3",3]]]],[11,"refract","","Simulate Snell\'s law refrection through a surface with…",5,[[["vec3",3]]]],[11,"lerp","","Linearly interpolate between two Vec3 with an…",5,[[["vec3",3]]]],[8,"Color","","Any type implementing this will be able to be used as an…",null,null],[10,"white","","",7,[[]]],[8,"SceneObject","","Represents something that has a distance field (through…",null,null],[10,"distance_to","","The distance from `point` to the nearest surface of the…",8,[[["vec3",3]]]],[10,"get_color","","The color of this object. May be useful if there are…",8,[[]]],[11,"normal","","Calculates the normal by finding the gradient of the…",8,[[["vec3",3]],["vec3",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"white","","",5,[[]]],[11,"distance_to","","",0,[[["vec3",3]]]],[11,"get_color","","",0,[[]]],[11,"distance_to","","TODO: This is messed up, fix for modular raymarching...",4,[[["vec3",3]]]],[11,"get_color","","",4,[[]]],[11,"from","","",5,[[]]],[11,"from","","",5,[[]]],[11,"from","","",5,[[]]],[11,"from","","",5,[[]]],[11,"clone","","",6,[[],["quaternion",3]]],[11,"clone","","",5,[[],["vec3",3]]],[11,"default","","",3,[[]]],[11,"default","","",5,[[]]],[11,"eq","","",5,[[["vec3",3]]]],[11,"ne","","",5,[[["vec3",3]]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"sub","","",5,[[["vec3",3]]]],[11,"add","","",6,[[["quaternion",3]]]],[11,"add","","",5,[[["vec3",3]]]],[11,"add","","",5,[[]]],[11,"mul","","",6,[[["quaternion",3]]]],[11,"mul","","",5,[[]]],[11,"neg","","",5,[[]]],[11,"normal","","Calculates the normal by finding the gradient of the…",8,[[["vec3",3]],["vec3",3]]]],"p":[[3,"Julia"],[3,"RayResult"],[3,"RayMarcher"],[3,"RayMarcherConfig"],[3,"Sphere"],[3,"Vec3"],[3,"Quaternion"],[8,"Color"],[8,"SceneObject"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);